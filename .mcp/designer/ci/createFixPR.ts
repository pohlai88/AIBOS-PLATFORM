export interface CreateFixPROptions {
  owner: string;
  repo: string;
  branch: string;
  base?: string;
  token: string;
  title?: string;
  body?: string;
  changes: Record<string, string>;
}

export interface CreateFixPRResult {
  success: boolean;
  prUrl?: string;
  prNumber?: number;
  error?: string;
}

export async function createFixPR(options: CreateFixPROptions): Promise<CreateFixPRResult> {
  const {
    owner,
    repo,
    branch,
    base = "main",
    token,
    title = "ðŸŽ¨ AI-BOS Designer AutoFix",
    body = "Automated design fixes generated by AI-BOS Designer MCP.",
    changes,
  } = options;

  if (Object.keys(changes).length === 0) {
    return { success: false, error: "No changes to commit" };
  }

  try {
    // Step 1: Get base branch SHA
    const baseRef = await getRef(owner, repo, base, token);
    if (!baseRef) {
      return { success: false, error: `Could not find base branch: ${base}` };
    }

    // Step 2: Create new branch
    const branchCreated = await createBranch(owner, repo, branch, baseRef, token);
    if (!branchCreated) {
      return { success: false, error: `Could not create branch: ${branch}` };
    }

    // Step 3: Create commits for each file
    for (const [filePath, content] of Object.entries(changes)) {
      const committed = await createOrUpdateFile(
        owner,
        repo,
        branch,
        filePath,
        content,
        `fix: auto-fix design issues in ${filePath}`,
        token
      );
      if (!committed) {
        console.warn(`Could not commit: ${filePath}`);
      }
    }

    // Step 4: Create PR
    const pr = await createPullRequest(owner, repo, branch, base, title, body, token);

    return pr;
  } catch (err) {
    return { success: false, error: String(err) };
  }
}

async function getRef(
  owner: string,
  repo: string,
  branch: string,
  token: string
): Promise<string | null> {
  const url = `https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${branch}`;

  const res = await fetch(url, {
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github.v3+json",
    },
  });

  if (!res.ok) return null;
  const data = (await res.json()) as { object: { sha: string } };
  return data.object.sha;
}

async function createBranch(
  owner: string,
  repo: string,
  branch: string,
  sha: string,
  token: string
): Promise<boolean> {
  const url = `https://api.github.com/repos/${owner}/${repo}/git/refs`;

  const res = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      ref: `refs/heads/${branch}`,
      sha,
    }),
  });

  return res.ok || res.status === 422; // 422 = already exists
}

async function createOrUpdateFile(
  owner: string,
  repo: string,
  branch: string,
  path: string,
  content: string,
  message: string,
  token: string
): Promise<boolean> {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;

  // Get existing file SHA if it exists
  const existingRes = await fetch(`${url}?ref=${branch}`, {
    headers: { Authorization: `Bearer ${token}` },
  });

  let sha: string | undefined;
  if (existingRes.ok) {
    const existing = (await existingRes.json()) as { sha: string };
    sha = existing.sha;
  }

  const res = await fetch(url, {
    method: "PUT",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      message,
      content: Buffer.from(content).toString("base64"),
      branch,
      sha,
    }),
  });

  return res.ok;
}

async function createPullRequest(
  owner: string,
  repo: string,
  head: string,
  base: string,
  title: string,
  body: string,
  token: string
): Promise<CreateFixPRResult> {
  const url = `https://api.github.com/repos/${owner}/${repo}/pulls`;

  const res = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ title, body, head, base }),
  });

  if (!res.ok) {
    return { success: false, error: await res.text() };
  }

  const data = (await res.json()) as { html_url: string; number: number };
  return { success: true, prUrl: data.html_url, prNumber: data.number };
}

